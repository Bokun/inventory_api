syntax = "proto3";

package io.bokun.inventory.common.api.grpc;

option java_multiple_files = true;
option java_package = "io.bokun.inventory.common.api.grpc";

// to signify that a RPC call doesn't return anything or has no input parameters
message Empty {
}

// All fields mandatory
message Date {
    int32 year = 1;
    int32 month = 2;
    int32 day = 3;
}

// Date period - from one day to another. Boundary conditions (exclusive or not) are defined at the context where this period is used.
// All fields mandatory
message DatePeriod {
    Date from = 1;
    Date to = 2;
}

// All fields mandatory
message Time {
    int32 hour = 1;
    int32 minute = 2;
}

// All fields mandatory
message Price {
    string currency = 1;
    string amount = 2;              // can't use double because of precision loss. Will convert to BigDecimal when data arrives in Java
}

// Data types for PluginConfigurationParameter
enum PluginParameterDataType {
    LONG = 0;
    DOUBLE = 1;
    BOOLEAN = 2;
    STRING = 3;
}

// What kind of features does this plugin support?
enum PluginCapability {
    SUPPORTS_PRICING = 0;
    SUPPORTS_RESERVATIONS = 1;
    SUPPORTS_AVAILABILITY = 2;
}

// Supported product categories
enum ProductCategory {
    ACCOMMODATION = 0;
    ACTIVITIES = 1;
    CAR_RENTALS = 2;
    TRANSPORT = 3;
}

// All fields mandatory; should at least be set to 0.
message Duration {
    int32 minutes = 1;
    int32 hours = 2;
    int32 days = 3;
    int32 weeks = 4;
}

message OpeningHoursTimeInterval {
    string openFrom = 1;                // Format: HH:mm
    int32 openForHours = 2;             // For how many hours open since openFrom
    int32 openForMinutes = 3;           // For how many minutes open since openFrom. Must be within [0..59]
    Duration duration = 4;              // Specifies the frequency between start times within the interval. For example if duration is 20 minutes, the tour starts every 20 minutes.
}

message OpeningHoursWeekday {
    bool open24Hours = 1;                                   // whether this is open 24/7. If so, other fields are irrelevant.
    repeated OpeningHoursTimeInterval timeIntervals = 2;    // only used if open24Hours is false. Time intervals that are open for this weekday
}

message OpeningHours {
    OpeningHoursWeekday monday = 1;         // Opening hours for Mondays
    OpeningHoursWeekday tuesday = 2;        // Tuesdays, and so on and so forth
    OpeningHoursWeekday wednesday = 3;
    OpeningHoursWeekday thursday = 4;
    OpeningHoursWeekday friday = 5;
    OpeningHoursWeekday saturday = 6;
    OpeningHoursWeekday sunday = 7;
}

message SeasonalOpeningHourSet {
    repeated SeasonalOpeningHours seasonalOpeningHours = 1;
}

message SeasonalOpeningHours {
    int32 startMonth = 1;
    int32 startDay = 2;
    int32 endMonth = 3;
    int32 endDay = 4;
    OpeningHours openingHours = 5;
}

enum BookingType {
    DATE = 0;
    DATE_AND_TIME = 1;
    PASS = 2;
}

// Rate (either of Bokun or remote system, depends on the context).
message Rate {
    // id for rate. Mandatory.
    string id = 1;

    // Label for rate. Mandatory.
    string label = 2;
}

// Parameters used to configure supported plugin(s)
message PluginConfigurationParameter {
    string name = 1;                        // names should be unique per plugin
    PluginParameterDataType type = 2;
    bool required = 3;
}

// Pricing category of (either of Bokun or remote system, depends on the context).
message PricingCategory {
    // id for pricing category. Mandatory.
    string id = 1;

    // Label for pricing category. Mandatory.
    string label = 2;
}

// Product description of a remote system product.
message ProductDescription {
    // Product id of remote system. Mandatory.
    string id = 1;

    // Product name of remote system. Mandatory.
    string name = 2;

    // Product description of remote system. Optional.
    string description = 3;

    // Product categories this product is sold at. Mandatory, should at least have one element in this collection.
    // This refers to pricing categories of the remote system.
    repeated PricingCategory pricingCategories = 4;

    // Rates this product is sold at. Mandatory, should at least have one element in this collection.
    // This refers to rates of the remote system.
    repeated Rate rates = 5;

    // If a product is available on a daily basis (without having pre-selected set of departure times), it will likely have opening hours,
    // much like a convenience store has a range of hours when it's open. Optional.
    oneof openingHours {
        // Guaranteed to be set if this product is available all year round without exception.
        OpeningHours allYearOpeningHours = 6;

        // Guaranteed to be set if this product is available at different times at different time periods within a year.
        SeasonalOpeningHourSet seasonalOpeningHours = 7;
    }

    // how is this product bookable? Mandatory.
    // -- if DATE, then this product does not have any start times
    // -- if DATE_AND_TIME, then this product is bookable for certain times within available days
    // -- if PASS, then this product is bookable so that participant could consume this product at any given day (providing ticket is not expired)
    BookingType bookingType = 8;

    // Whether pickup is available for this product. Mandatory.
    bool pickupAvailable = 9;

    // Whether customer can be picked up at an arbitrary place, specified during booking process.
    // Mandatory if ::pickupAvailable is true, otherwise irrelevant/ignored.
    bool customPickupPlaceAllowed = 10;

    // How many minutes somebody should be picked up before the event takes place.
    int32 pickupMinutesBefore = 11;

    // A collection of pre-defined pick up places, supported by vendor.
    // Mandatory (should have at least one entry) if ::pickupAvailable is true and ::customPickupPlaceAllowed is false.
    repeated PickupDropoffPlace pickupPlaces = 12;

    // Whether drop off is available for this product. Mandatory.
    bool dropoffAvailable = 13;

    // Whether customer can be dropped off at arbitrary place, specified during booking process.
    // Mandatory if ::dropoffAvailable is true, otherwise irrelevant/ignored.
    bool customDropoffAvailable = 14;

    // A collection of pre-defined drop off places, supported by vendor.
    // Mandatory (should have at least one entry) if ::dropoffAvailable is true and ::customDropoffPlaceAllowed is false.
    repeated PickupDropoffPlace dropoffPlaces = 15;

    // Is this activity, accommodation, etc.? Mandatory.
    ProductCategory productCategory = 16;

    // What kind of tickets does this product support?
    repeated TicketSupport ticketSupport = 17;
}

// A list of all possible ticketing options for a product.
enum TicketSupport {
    NONE = 0;
    TICKET_PER_PERSON = 1;
    TICKET_PER_BOOKING = 2;
}

// Types of tickets supported by remote systems
enum TicketType {
    QR_CODE = 0;
}

message QrTicket {
    string ticketBarcode = 1;
}

message Ticket {
    oneof ticket {
        QrTicket qrTicket = 1;
    }
}

message PickupDropoffPlace {
    // Verbal description of pick up place. Mandatory.
    string title = 1;

    // Precise location of pick up place. Optional.
    GeoPoint location = 2;
}

// Parameters used to configure supported plugin(s)
message PluginConfigurationParameterValue {
    // refer to PluginConfigurationParameter::name
    string name = 1;

    // value for this name; null strings are not permitted by proto v3 but empty strings "" are
    string value = 2;
}

// represents a point in map.
message GeoPoint {
    double latitude = 1;
    double longitude = 2;
}

// Represents a location from the United Nations Code for Trade and Transport Locations (UN/LOCODE).
message UnLocode {
    // ISO 3166-1 alpha-2 string identifying the country part of the UN/LOCODE for this product.
    string country = 1;

    // A three letter String identifying the city part of the UN/LOCODE for this product.
    string city = 2;
}

message Address {
    string addressLine1 = 1;
    string addressLine2 = 2;
    string addressLine3 = 3;
    string city = 4;
    string state = 5;
    string postalCode = 6;
    string countryCode = 7;
    GeoPoint geoPoint = 8;
    UnLocode unLocode = 9;
}

message Place {
    string title = 1;
    Address address = 2;
}

message ReservationResponse {
    // should return either success or failure data structure. Mandatory (response must indicate either succees or failure).
    oneof reservationResult {
        SuccessfulReservation successfulReservation = 1;
        FailedReservation failedReservation = 2;
    }
}

message SuccessfulReservation {
    // Reservation code. Mandatory. Note: this might or might not differ from booking confirmation code, depending on plugin implementation.
    string reservationConfirmationCode = 1;
}

message FailedReservation {
    // Error message telling why this request has failed. Optional - remote end is not required to explicitly tell the reason of failure
    string reservationError = 1;
}

message ConfirmBookingResponse {
    // should return either success or failure data structure. Mandatory (response must indicate either succees or failure).
    oneof bookingResult {
        SuccessfulBooking successfulBooking = 1;
        FailedReservation failedBooking = 2;
    }
}

message SuccessfulBooking {
    // This may or may not overlap with ReservationResponse::reservationConfirmationCode, depending on the specifics of the remote plugin.
    // Either case, mandatory.
    string bookingConfirmationCode = 1;
    repeated Ticket tickets = 2;
}

message FailedBooking {
    // Error message telling why this request has failed. Optional - remote end is not required to explicitly tell the reason of failure
    string bookingError = 1;
}

message Contact {
    // First name. Mandatory.
    string firstName = 1;

    // Last name. Mandatory.
    string lastName = 2;

    // Title, optional.
    string title = 3;

    // Optional email address. It is also possible to store multiple addresses in this field, separated by comma (as per RFC2822).
    string email = 4;

    // Phone including intl code. Optional.
    string phone = 5;

    // Language customer prefers to be contacted in. Optional.
    string language = 6;

    // ISO 3166-1 Alpha-3 code, see https://en.wikipedia.org/wiki/ISO_3166-1. Optional.
    string nationality = 7;
}

message ProductAvailabilityWithRatesResponse {
    // How many slots are available for this day/time. Mandatory.
    int32 capacity = 1;

    // Date for when this product is available. Mandatory.
    Date date = 2;

    // When does this event start? Unset if this product does not support times.
    Time time = 3;

    // When does a pickup for this product start? Unset if this product does not support times or pickups.
    Time pickupTime = 4;

    // Rates with prices. Mandatory (should at least have one entry).
    repeated RateWithPrice rates = 5;
}

message RateWithPrice {
    // What rate ("12 hour rate", "24 hour rate"). Mandatory. If the remote end does not support rates, plugins should at least return some
    // superficial rate.
    Rate rate = 1;

    // Pricing categories with prices for given availability slot. Mandatory (should at least have a single entry).
    repeated PricingCategoryWithPrice pricingCategories = 2;
}

message PricingCategoryWithPrice {
    PricingCategory pricingCategory = 1;
    Price price = 2;
}
